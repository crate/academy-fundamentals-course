<p>In this video, you'll see how CrateDB's container data types, <span style="font-family: terminal, monospace;">OBJECT</span>, and <span style="font-family: terminal, monospace;">ARRAY</span> make CrateDB a powerful database for storing and retrieving document data. We'll look at the different ways that an object schema can be specified in CreateDB, touch on how CrateDB indexes objects, and try out some example queries.</p>
<p>JSON documents are everywhere. It's a common way of representing data, with many programming languages supporting the format. Sometimes these documents have a fixed schema, but it's not unusual for documents describing the same sort of data to differ in their representation of it. Here we have two JSON documents describing community areas in Chicago. The document on the right has additional <span style="font-family: terminal, monospace;">notableresident</span> and <span style="font-family: terminal, monospace;">zipcodes</span> components. <span style="font-family: terminal, monospace;">notableresident</span> is an <span style="font-family: terminal, monospace;">OBJECT</span>, <span style="font-family: terminal, monospace;">zipcodes</span> is an <span style="font-family: terminal, monospace;">ARRAY</span>.</p>
<p>Sometimes we want to create and enforce a strict schema for these documents, rejecting those that don't conform to it. For example, here we might want to reject the document for Norwood Park as it contains extra data we haven't planned for. In other cases, we want the flexibility to store and query such semi or unstructured documents in a single collection. How do we store and query these semi and unstructured data types in a relational type table? CrateDB has two container data types that enable us to model this sort of data in a flexible way. We'll begin by exploring the <span style="font-family: terminal, monospace;">OBJECT</span> type, then briefly touch on the second container type, the <span style="font-family: terminal, monospace;">ARRAY</span>.</p>
<p>Let's explore the different ways in which we can model objects with CrateDB using our <span style="font-family: terminal, monospace;">community_areas</span> data set. Here I'm creating a table for community areas using the <span style="font-family: terminal, monospace;">areanumber</span> as an <span style="font-family: terminal, monospace;">INTEGER PRIMARY KEY</span> and a <span style="font-family: terminal, monospace;">TEXT</span> field to store the area name. For everything else, I'm going to use an <span style="font-family: terminal, monospace;">OBJECT</span> named <span style="font-family: terminal, monospace;">details</span>. Inside that object, I've described a schema containing a <span style="font-family: terminal, monospace;">TEXT</span> field for <span style="font-family: terminal, monospace;">description</span> and a <span style="font-family: terminal, monospace;">BIGINT</span> field for <span style="font-family: terminal, monospace;">population</span>. Note that I've used the <span style="font-family: terminal, monospace;">STRICT</span> object policy, which means that CrateDB will enforce this schema and reject records that don't match it.</p>
<p>We'll go ahead and create the table, and now I'll paste in an <span style="font-family: terminal, monospace;">INSERT</span> statement. What we see here is that we're inserting a new record into the table, for area 35. It's called Douglas. It has a <span style="font-family: terminal, monospace;">description</span> and a <span style="font-family: terminal, monospace;">population</span> inside its <span style="font-family: terminal, monospace;">details</span> object. And you can see that that object is expressed as a JSON literal here in the insert statement. When I execute this statement, you'll see that again we get result OK, this object and this record were inserted into the table.</p>
<p>If we try again with a slightly different version of this where here I've added a <span style="font-family: terminal, monospace;">notableresident</span> sub-object that's not in our table schema. What we should see when I click execute is that we get a SQL error because the column <span style="font-family: terminal, monospace;">notableresident</span> isn't allowed inside the object details. This is where CrateDB has enforced that schema and has rejected this insert.</p>
<p>Let's create an alternative version of our <span style="font-family: terminal, monospace;">community_areas</span> table. This time I'm using the <span style="font-family: terminal, monospace;">DYNAMIC</span> object policy for the <span style="font-family: terminal, monospace;">details</span> object. This is the default in CrateDB. What this means is that when CrateDB encounters fields that are in the <span style="font-family: terminal, monospace;">details</span> object that are not in the schema, it will add them anyway and infer the appropriate data type. Let's create the table and now let's paste in a community area. In this version of the Douglas community area, I have that extra <span style="font-family: terminal, monospace;">notableresident</span> object that was not mentioned in the schema. When we run this query, it will run and execute without error. So let's see what the state of the table looks like now.</p>
<p>If we run the <span style="font-family: terminal, monospace;">SHOW CREATE TABLE community_areas</span> command, you'll see that there is a schema down here and this schema now contains <span style="font-family: terminal, monospace;">notableresident</span> object with field <span style="font-family: terminal, monospace;">name</span> and <span style="font-family: terminal, monospace;">description</span> that have been inferred as <span style="font-family: terminal, monospace;">TEXT</span>. In this way, CrateDB has accepted a dynamic object, modified the schema accordingly and will index all of these values for us. The final policy to look at is ignored.</p>
<p>Here I'm creating a third version of the <span style="font-family: terminal, monospace;">community_areas</span> table, and my <span style="font-family: terminal, monospace;">details</span> object is specified as <span style="font-family: terminal, monospace;">OBJECT IGNORED</span>. This means that CrateDB will accept fields that are not specified in the schema, but it won't index these. This means that we can store objects that have different shapes inside this object, and we'll see what that means shortly.</p>
<p>Let's first create the table and paste in an example record here for the <span style="font-family: terminal, monospace;">community_areas</span>, Douglas, we have an object containing <span style="font-family: terminal, monospace;">notableresident</span>, which wasn't part of the schema. And note that that itself has some structure inside there. There's an <span style="font-family: terminal, monospace;">address</span> sub-object, so let's create that and that worked.</p>
<p>Now what we're going to do is add a second record that has a slightly different structure from the 1st. I'm going to add a record for a neighbourhood called Norwood Park, and here it is. In this case we also have this <span style="font-family: terminal, monospace;">notableresident</span> object that wasn't part of our object schema, but now inside that the <span style="font-family: terminal, monospace;">address</span> is a string. It's no longer another object like it was in the previous record. We execute this, CrateDB stores that, and what's happened here is that the <span style="font-family: terminal, monospace;">notableresident </span>sub-object and anything inside it has been stored and can be queried, but hasn't been indexed. This means that when we run a query such as this one, you can see that we get back different versions of the address because each record that we inserted had a different data type there. In one case it was a string, in the other case it's an object.</p>
<p>The other container data type in CrateDB is an <span style="font-family: terminal, monospace;">ARRAY</span>. This is a container for other data types, including objects. Here I'm creating another version of the <span style="font-family: terminal, monospace;">community_areas</span> table, and inside my <span style="font-family: terminal, monospace;">details</span> object I've chosen to model an array of zip codes as <span style="font-family: terminal, monospace;">TEXT</span>. Let's create the table and let's look at an example record.</p>
<p>Here I'm inserting a record for Norwood Park which now has an array of zip codes containing 3 text strings. Let's create that. Now how do we query these? If we take a look at this <span style="font-family: terminal, monospace;">SELECT</span> query here, what we see is that there is a Python like syntax for slicing arrays. So here I'm asking CrateDB to select the first two entries in the <span style="font-family: terminal, monospace;">zipcodes</span> array from the <span style="font-family: terminal, monospace;">details</span> object in the field <span style="font-family: terminal, monospace;">zipcodes</span> where the area number is 10, which is Norwood Park. Let's go ahead and run that and you'll see that we get an array response containing those first 2 zip codes. Now you've seen how CrateDB can store and query JSON data using the <span style="font-family: terminal, monospace;">OBJECT</span> and <span style="font-family: terminal, monospace;">ARRAY</span> data types. As the next step, I'd encourage you to experiment with the different object policies and try queries against the sample data set in your CrateDB cluster.</p>